<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Part III. Loose coupling with strong typing</title><link rel="stylesheet" href="css/weld.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="Weld 2.3.0.Final - CDI Reference Implementation"/><link rel="up" href="index.html" title="Weld 2.3.0.Final - CDI Reference Implementation"/><link rel="prev" href="weldexamples.html" title="Chapter 7. Diving into the Weld examples"/><link rel="next" href="producer_methods.html" title="Chapter 8. Producer methods"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://weld.cdi-spec.org" class="site_href"><strong>Weld Site</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="weldexamples.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="producer_methods.html"><strong>Next</strong></a></li></ul><div class="part" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a id="part-3"/>Part III. Loose coupling with strong typing</h1></div></div></div><div class="partintro" lang="en-US"><div/><p>The first major theme of CDI is <span class="emphasis"><em>loose coupling</em></span>. We’ve already seen
three means of achieving loose coupling:</p><div class="itemizedlist"><ul><li><span class="emphasis"><em>alternatives</em></span> enable deployment time polymorphism,</li><li><span class="emphasis"><em>producer methods</em></span> enable runtime polymorphism, and</li><li><span class="emphasis"><em>contextual lifecycle management</em></span> decouples bean lifecycles.</li></ul></div><p>These techniques serve to enable loose coupling of client and server.
The client is no longer tightly bound to an implementation of an
interface, nor is it required to manage the lifecycle of the
implementation. This approach lets <span class="emphasis"><em>stateful objects interact as if they
were services</em></span>.</p><p>Loose coupling makes a system more <span class="emphasis"><em>dynamic</em></span>. The system can respond to
change in a well-defined manner. In the past, frameworks that attempted
to provide the facilities listed above invariably did it by sacrificing
type safety (most notably by using XML descriptors). CDI is the first
technology, and certainly the first specification in the Java EE
platform, that achieves this level of loose coupling in a typesafe way.</p><p>CDI provides three extra important facilities that further the goal of
loose coupling:</p><div class="itemizedlist"><ul><li><span class="emphasis"><em>interceptors</em></span> decouple technical concerns from business logic,</li><li><span class="emphasis"><em>decorators</em></span> may be used to decouple some business concerns, and</li><li><span class="emphasis"><em>event notifications</em></span> decouple event producers from event consumers.</li></ul></div><p>The second major theme of CDI is <span class="emphasis"><em>strong typing</em></span>. The information about
the dependencies, interceptors and decorators of a bean, and the
information about event consumers for an event producer, is contained in
typesafe Java constructs that may be validated by the compiler.</p><p>You don’t see string-based identifiers in CDI code, not because the
framework is hiding them from you using clever defaulting
rules—so-called "configuration by convention"—but because there are
simply no strings there to begin with!</p><p>The obvious benefit of this approach is that <span class="emphasis"><em>any</em></span> IDE can provide
autocompletion, validation and refactoring without the need for special
tooling. But there is a second, less-immediately-obvious, benefit. It
turns out that when you start thinking of identifying objects, events or
interceptors via annotations instead of names, you have an opportunity
to lift the semantic level of your code.</p><p>CDI encourages you develop annotations that model concepts, for example,</p><div class="itemizedlist"><ul><li><code class="literal">@Asynchronous</code>,</li><li><code class="literal">@Mock</code>,</li><li><code class="literal">@Secure</code> or</li><li><code class="literal">@Updated</code>,</li></ul></div><p>instead of using compound names like</p><div class="itemizedlist"><ul><li><code class="literal">asyncPaymentProcessor</code>,</li><li><code class="literal">mockPaymentProcessor</code>,</li><li><code class="literal">SecurityInterceptor</code> or</li><li><code class="literal">DocumentUpdatedEvent</code>.</li></ul></div><p>The annotations are reusable. They help describe common qualities of
disparate parts of the system. They help us categorize and understand
our code. They help us deal with common concerns in a common way. They
make our code more literate and more understandable.</p><p>CDI <span class="emphasis"><em>stereotypes</em></span> take this idea a step further. A stereotype models a
common <span class="emphasis"><em>role</em></span> in your application architecture. It encapsulates various
properties of the role, including scope, interceptor bindings,
qualifiers, etc, into a single reusable package. (Of course, there is
also the benefit of tucking some of those annotations away).</p><p>We’re now ready to meet some more advanced features of CDI. Bear in mind
that these features exist to make our code both easier to validate and
more understandable. Most of the time you don’t ever really <span class="emphasis"><em>need</em></span> to
use these features, but if you use them wisely, you’ll come to
appreciate their power.</p><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="producer_methods.html">8. Producer methods</a></span></dt><dd><dl><dt><span class="section"><a href="producer_methods.html#_scope_of_a_producer_method">8.1. Scope of a producer method</a></span></dt><dt><span class="section"><a href="producer_methods.html#_injection_into_producer_methods">8.2. Injection into producer methods</a></span></dt><dt><span class="section"><a href="producer_methods.html#_use_of_literal_new_literal_with_producer_methods">8.3. Use of @New with producer methods</a></span></dt><dt><span class="section"><a href="producer_methods.html#_disposer_methods">8.4. Disposer methods</a></span></dt></dl></dd><dt><span class="chapter"><a href="interceptors.html">9. Interceptors</a></span></dt><dd><dl><dt><span class="section"><a href="interceptors.html#_interceptor_bindings">9.1. Interceptor bindings</a></span></dt><dt><span class="section"><a href="interceptors.html#_implementing_interceptors">9.2. Implementing interceptors</a></span></dt><dt><span class="section"><a href="interceptors.html#_enabling_interceptors">9.3. Enabling interceptors</a></span></dt><dt><span class="section"><a href="interceptors.html#_interceptor_bindings_with_members">9.4. Interceptor bindings with members</a></span></dt><dt><span class="section"><a href="interceptors.html#_multiple_interceptor_binding_annotations">9.5. Multiple interceptor binding annotations</a></span></dt><dt><span class="section"><a href="interceptors.html#_interceptor_binding_type_inheritance">9.6. Interceptor binding type inheritance</a></span></dt><dt><span class="section"><a href="interceptors.html#_use_of_literal_interceptors_literal">9.7. Use of @Interceptors</a></span></dt></dl></dd><dt><span class="chapter"><a href="decorators.html">10. Decorators</a></span></dt><dd><dl><dt><span class="section"><a href="decorators.html#_delegate_object">10.1. Delegate object</a></span></dt><dt><span class="section"><a href="decorators.html#_enabling_decorators">10.2. Enabling decorators</a></span></dt></dl></dd><dt><span class="chapter"><a href="events.html">11. Events</a></span></dt><dd><dl><dt><span class="section"><a href="events.html#_event_payload">11.1. Event payload</a></span></dt><dt><span class="section"><a href="events.html#_event_observers">11.2. Event observers</a></span></dt><dt><span class="section"><a href="events.html#_event_producers">11.3. Event producers</a></span></dt><dt><span class="section"><a href="events.html#_conditional_observer_methods">11.4. Conditional observer methods</a></span></dt><dt><span class="section"><a href="events.html#_event_qualifiers_with_members">11.5. Event qualifiers with members</a></span></dt><dt><span class="section"><a href="events.html#_multiple_event_qualifiers">11.6. Multiple event qualifiers</a></span></dt><dt><span class="section"><a href="events.html#_transactional_observers">11.7. Transactional observers</a></span></dt></dl></dd><dt><span class="chapter"><a href="stereotypes.html">12. Stereotypes</a></span></dt><dd><dl><dt><span class="section"><a href="stereotypes.html#_default_scope_for_a_stereotype">12.1. Default scope for a stereotype</a></span></dt><dt><span class="section"><a href="stereotypes.html#_interceptor_bindings_for_stereotypes">12.2. Interceptor bindings for stereotypes</a></span></dt><dt><span class="section"><a href="stereotypes.html#_name_defaulting_with_stereotypes">12.3. Name defaulting with stereotypes</a></span></dt><dt><span class="section"><a href="stereotypes.html#_alternative_stereotypes">12.4. Alternative stereotypes</a></span></dt><dt><span class="section"><a href="stereotypes.html#_stereotype_stacking">12.5. Stereotype stacking</a></span></dt><dt><span class="section"><a href="stereotypes.html#_built_in_stereotypes">12.6. Built-in stereotypes</a></span></dt></dl></dd><dt><span class="chapter"><a href="specialization.html">13. Specialization, inheritance and alternatives</a></span></dt><dd><dl><dt><span class="section"><a href="specialization.html#_using_alternative_stereotypes">13.1. Using alternative stereotypes</a></span></dt><dt><span class="section"><a href="specialization.html#_a_minor_problem_with_alternatives">13.2. A minor problem with alternatives</a></span></dt><dt><span class="section"><a href="specialization.html#_using_specialization">13.3. Using specialization</a></span></dt></dl></dd><dt><span class="chapter"><a href="resources.html">14. Java EE component environment resources</a></span></dt><dd><dl><dt><span class="section"><a href="resources.html#_defining_a_resource">14.1. Defining a resource</a></span></dt><dt><span class="section"><a href="resources.html#_typesafe_resource_injection">14.2. Typesafe resource injection</a></span></dt></dl></dd></dl></div></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="weldexamples.html"><strong>Prev</strong>Chapter 7. Diving into the Weld examples</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="producer_methods.html"><strong>Next</strong>Chapter 8. Producer methods</a></li></ul></body></html>